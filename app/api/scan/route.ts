import { NextRequest } from "next/server";
import { spawn } from "child_process";
import * as path from "path";
import * as fs from "fs";

// Increase Next.js API route timeout (this is a long-running operation)
export const maxDuration = 300; // 5 minutes (Vercel limit is 300s on Pro, 10s on Hobby)

export async function POST(req: NextRequest) {
  try {
    // Parse request body for UI-controlled options
    let autoGenerateDocuments = "true"; // Default to true
    let maxJobs = "5"; // Default to 5
    try {
      const bodyText = await req.text();
      if (bodyText) {
        const body = JSON.parse(bodyText);
        if (typeof body.autoGenerateDocuments === "boolean") {
          autoGenerateDocuments = body.autoGenerateDocuments ? "true" : "false";
        }
        if (typeof body.maxJobs === "number" && [5, 10, 20, 30].includes(body.maxJobs)) {
          maxJobs = String(body.maxJobs);
        }
      }
    } catch (e) {
      // If body parsing fails or no body, use defaults
      console.log(`[Scan API] No request body or parse error, using defaults`);
    }
    
    console.log(`[Scan API] Starting scan with MAX_JOBS=${maxJobs}, AUTO_GENERATE_DOCUMENTS=${autoGenerateDocuments}`);
    
    // Spawn the jobright scan script exactly as npm run jobright:scan would
    // npm run jobright:scan executes: tsx scripts/jobrightScan.ts
    const scriptPath = path.join(process.cwd(), "scripts", "jobrightScan.ts");
    
    // Use the local tsx binary (same as npm run would use)
    const tsxPath = path.join(process.cwd(), "node_modules", ".bin", "tsx");
    const useLocalTsx = fs.existsSync(tsxPath);
    
    // Execute exactly like npm run jobright:scan
    const child = spawn(
      useLocalTsx ? tsxPath : "tsx", // Use local tsx if available, otherwise fallback to global
      [scriptPath],
      {
        cwd: process.cwd(), // Same working directory as npm run
        env: {
          ...process.env, // Inherit all environment variables (same as npm run)
          // Override with UI-controlled values
          MAX_JOBS: maxJobs,
          AUTO_GENERATE_DOCUMENTS: autoGenerateDocuments,
        },
        stdio: ["ignore", "pipe", "pipe"], // Capture stdout and stderr
        shell: false, // Don't use shell (same as npm run)
      }
    );

    let output = "";
    let errorOutput = "";

    child.stdout?.on("data", (data) => {
      const text = data.toString();
      output += text;
      // Log to console for debugging
      console.log("[Scan]", text.trim());
    });

    child.stderr?.on("data", (data) => {
      const text = data.toString();
      errorOutput += text;
      // Log to console for debugging
      console.error("[Scan Error]", text.trim());
    });

    // Wait for the process to complete (with a timeout)
    const timeout = 280000; // 4.5 minutes (slightly less than maxDuration)
    const processPromise = new Promise<{ success: boolean; output: string; error: string }>((resolve) => {
      child.on("close", (code) => {
        resolve({
          success: code === 0,
          output,
          error: errorOutput,
        });
      });
      
      child.on("error", (err) => {
        resolve({
          success: false,
          output,
          error: errorOutput + "\n" + err.message,
        });
      });
    });

    const timeoutPromise = new Promise<{ success: boolean; output: string; error: string }>((resolve) => {
      setTimeout(() => {
        child.kill("SIGTERM");
        resolve({
          success: false,
          output,
          error: "Process timed out after 4.5 minutes",
        });
      }, timeout);
    });

    const result = await Promise.race([processPromise, timeoutPromise]);

    // Clean up
    if (child.killed === false) {
      child.kill("SIGTERM");
    }

    return new Response(
      JSON.stringify({
        success: result.success,
        message: result.success ? "Scan completed successfully" : "Scan failed or timed out",
        output: result.output.substring(0, 1000), // Limit output size
        error: result.error.substring(0, 1000), // Limit error size
      }),
      {
        status: result.success ? 200 : 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  } catch (error: any) {
    return new Response(
      JSON.stringify({
        success: false,
        message: "Failed to start scan",
        error: error.message,
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }
}
