import { NextRequest } from "next/server";
import { spawn } from "child_process";
import * as path from "path";

// Increase Next.js API route timeout (this is a long-running operation)
export const maxDuration = 300; // 5 minutes (Vercel limit is 300s on Pro, 10s on Hobby)

export async function POST(req: NextRequest) {
  try {
    // Parse request body for UI-controlled options
    let autoGenerateDocuments = "true"; // Default to true
    try {
      const bodyText = await req.text();
      if (bodyText) {
        const body = JSON.parse(bodyText);
        if (typeof body.autoGenerateDocuments === "boolean") {
          autoGenerateDocuments = body.autoGenerateDocuments ? "true" : "false";
        }
      }
    } catch (e) {
      // If body parsing fails or no body, use default (true)
      console.log(`[Scan API] No request body or parse error, using default AUTO_GENERATE_DOCUMENTS=true`);
    }
    
    console.log(`[Scan API] Starting scan with AUTO_GENERATE_DOCUMENTS=${autoGenerateDocuments}`);
    
    // Spawn the jobright scan script as a child process
    const scriptPath = path.join(process.cwd(), "scripts", "jobrightScan.ts");
    
    // Use tsx to run the TypeScript file
    const child = spawn("npx", ["tsx", scriptPath], {
      cwd: process.cwd(),
      env: {
        ...process.env,
        // Pass through environment variables
        DATABASE_URL: process.env.DATABASE_URL,
        JOBRIGHT_CONTEXT_DIR: process.env.JOBRIGHT_CONTEXT_DIR,
        JOBBOT_USER_ID: process.env.JOBBOT_USER_ID,
        MAX_JOBS: process.env.MAX_JOBS || "5",
        AUTO_GENERATE_DOCUMENTS: autoGenerateDocuments, // Controlled by UI
      },
      stdio: ["ignore", "pipe", "pipe"], // Ignore stdin, capture stdout and stderr
      detached: false, // Keep attached to parent process
    });

    let output = "";
    let errorOutput = "";

    child.stdout?.on("data", (data) => {
      const text = data.toString();
      output += text;
      // Log to console for debugging
      console.log("[Scan]", text.trim());
    });

    child.stderr?.on("data", (data) => {
      const text = data.toString();
      errorOutput += text;
      // Log to console for debugging
      console.error("[Scan Error]", text.trim());
    });

    // Wait for the process to complete (with a timeout)
    const timeout = 280000; // 4.5 minutes (slightly less than maxDuration)
    const processPromise = new Promise<{ success: boolean; output: string; error: string }>((resolve) => {
      child.on("close", (code) => {
        resolve({
          success: code === 0,
          output,
          error: errorOutput,
        });
      });
      
      child.on("error", (err) => {
        resolve({
          success: false,
          output,
          error: errorOutput + "\n" + err.message,
        });
      });
    });

    const timeoutPromise = new Promise<{ success: boolean; output: string; error: string }>((resolve) => {
      setTimeout(() => {
        child.kill("SIGTERM");
        resolve({
          success: false,
          output,
          error: "Process timed out after 4.5 minutes",
        });
      }, timeout);
    });

    const result = await Promise.race([processPromise, timeoutPromise]);

    // Clean up
    if (child.killed === false) {
      child.kill("SIGTERM");
    }

    return new Response(
      JSON.stringify({
        success: result.success,
        message: result.success ? "Scan completed successfully" : "Scan failed or timed out",
        output: result.output.substring(0, 1000), // Limit output size
        error: result.error.substring(0, 1000), // Limit error size
      }),
      {
        status: result.success ? 200 : 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  } catch (error: any) {
    return new Response(
      JSON.stringify({
        success: false,
        message: "Failed to start scan",
        error: error.message,
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }
}
